use super::channel::NodeOrder;
use super::BYTES;
use std::any::Any;
use std::sync::{Arc, RwLock};
use uuid::Uuid;

/// # FromBinary
/// trait for convert binary to struct.
#[async_trait::async_trait]
pub trait FromToBinary {
    /// make something from binary when its size is known.
    async fn from_binary(binary: Arc<RwLock<&[u8]>>) -> Result<Self, ()>
    where
        Self: Sized;

    /// convert Self to binary.
    fn to_binary(&self) -> Vec<u8>;
}

/// # Shared
/// trait object for send data between nodes.
pub type SharedAny = dyn Any + Send + Sync + 'static;

/// # Envelope
/// Input envelope.
#[derive(Debug)]
pub struct Envelope {
    // todo
}

impl Envelope {
    // todo

    pub fn new() -> Self {
        Envelope {}
    }

    pub fn value(&self) -> f64 {
        todo!()
    }
}

// result of try_recv_request
// NodeOrder, Empty, Disconnected
pub enum TryRecvResult {
    /// vector of NodeOrder and downstream SocketId.
    Order(Vec<(NodeOrder, SocketId)>),
    Empty,
}

/// NodeId
/// - NodeId is a unique identifier generated by Uuid for each node.
/// # Example
/// ```
/// use node::types::NodeId;
/// let id = NodeId::new();
/// let id_str = id.to_string();
/// assert_eq!(id, NodeId::from_string(&id_str));
/// ```
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct NodeId(Uuid);

impl NodeId {
    pub fn new() -> Self {
        NodeId(Uuid::new_v4())
    }
    pub fn to_string(&self) -> String {
        self.0.to_string()
    }
    pub fn from_string(id: &str) -> Self {
        NodeId(Uuid::parse_str(id).unwrap())
    }

    pub fn to_binary(&self) -> Vec<u8> {
        let id_str = self.to_string();
        let len = id_str.len();
        let mut bin = vec![0; len + BYTES];
        bin[0..BYTES].copy_from_slice(&len.to_be_bytes());
        bin[BYTES..].copy_from_slice(id_str.as_bytes());
        bin
    }

    pub fn from_binary(binary: &[u8]) -> (Self, &[u8]) {
        let len = usize::from_be_bytes(binary[0..BYTES].try_into().unwrap());
        let id_str = String::from_utf8(binary[BYTES..BYTES + len].to_vec()).unwrap();
        (NodeId::from_string(&id_str), &binary[BYTES + len..])
    }
}

pub type NodeName = String;

/// SocketId
/// - SocketId is a unique identifier generated by Uuid for each socket.
/// # Example
/// ```
/// use node::types::SocketId;
/// let id = SocketId::new();
/// let id_str = id.to_string();
/// assert_eq!(id, SocketId::from_string(&id_str));
/// ```
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SocketId(Uuid);

impl SocketId {
    pub fn new() -> Self {
        SocketId(Uuid::new_v4())
    }
    pub fn to_string(&self) -> String {
        self.0.to_string()
    }
    pub fn from_string(id: &String) -> Self {
        SocketId(Uuid::parse_str(id).unwrap())
    }

    pub fn to_binary(&self) -> Vec<u8> {
        let id_str = self.to_string();
        let len = id_str.len();
        let mut bin = vec![0; len + BYTES];
        bin[0..BYTES].copy_from_slice(&len.to_be_bytes());
        bin[BYTES..].copy_from_slice(id_str.as_bytes());
        bin
    }

    pub fn from_binary(binary: &[u8]) -> (Self, &[u8]) {
        let len = usize::from_be_bytes(binary[0..BYTES].try_into().unwrap());
        let id_str = String::from_utf8(binary[BYTES..BYTES + len].to_vec()).unwrap();
        (SocketId::from_string(&id_str), &binary[BYTES + len..])
    }
}
