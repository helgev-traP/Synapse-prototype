use super::BYTES_IN_WORD;
use std::any::Any;
use std::sync::{Arc, RwLock};
use uuid::Uuid;

/// # FromBinary
/// trait for convert binary to struct.
#[async_trait::async_trait]
pub trait FromToBinary {
    /// make something from binary when its size is known.
    async fn from_binary(binary: Arc<RwLock<&[u8]>>) -> Result<Self, ()>
    where
        Self: Sized;

    /// convert Self to binary.
    fn to_binary(&self) -> Vec<u8>;
}

/// # Shared
/// trait object for send data between nodes.
pub type SharedAny = dyn Any + Send + Sync + 'static;

/// NodeId
/// - NodeId is a unique identifier generated by Uuid for each node.
/// # Example
/// ```
/// use node::types::NodeId;
/// let id = NodeId::new();
/// let id_str = id.to_string();
/// assert_eq!(id, NodeId::from_string(&id_str));
/// ```
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct NodeId(Uuid);

impl std::fmt::Display for NodeId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl NodeId {
    // Allow clippy::new_without_default to make it clear that id is generated randomly.
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        NodeId(Uuid::new_v4())
    }

    pub fn from_string(id: &str) -> Self {
        NodeId(Uuid::parse_str(id).unwrap())
    }

    pub fn to_binary(&self) -> Vec<u8> {
        let id_str = self.to_string();
        let len = id_str.len();
        let mut bin = vec![0; len + BYTES_IN_WORD];
        bin[0..BYTES_IN_WORD].copy_from_slice(&len.to_be_bytes());
        bin[BYTES_IN_WORD..].copy_from_slice(id_str.as_bytes());
        bin
    }

    pub fn from_binary(binary: &[u8]) -> (Self, &[u8]) {
        let len = usize::from_be_bytes(binary[0..BYTES_IN_WORD].try_into().unwrap());
        let id_str =
            String::from_utf8(binary[BYTES_IN_WORD..BYTES_IN_WORD + len].to_vec()).unwrap();
        (NodeId::from_string(&id_str), &binary[BYTES_IN_WORD + len..])
    }
}

pub type NodeName = String;

/// SocketId
/// - SocketId is a unique identifier generated by Uuid for each socket.
/// # Example
/// ```
/// use node::types::SocketId;
/// let id = SocketId::new();
/// let id_str = id.to_string();
/// assert_eq!(id, SocketId::from_string(&id_str));
/// ```
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SocketId(Uuid);

impl std::fmt::Display for SocketId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl SocketId {
    // Allow clippy::new_without_default to make it clear that id is generated randomly.
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        SocketId(Uuid::new_v4())
    }

    pub fn from_string(id: &str) -> Self {
        SocketId(Uuid::parse_str(id).unwrap())
    }

    pub fn to_binary(&self) -> Vec<u8> {
        let id_str = self.to_string();
        let len = id_str.len();
        let mut bin = vec![0; len + BYTES_IN_WORD];
        bin[0..BYTES_IN_WORD].copy_from_slice(&len.to_be_bytes());
        bin[BYTES_IN_WORD..].copy_from_slice(id_str.as_bytes());
        bin
    }

    pub fn from_binary(binary: &[u8]) -> (Self, &[u8]) {
        let len = usize::from_be_bytes(binary[0..BYTES_IN_WORD].try_into().unwrap());
        let id_str =
            String::from_utf8(binary[BYTES_IN_WORD..BYTES_IN_WORD + len].to_vec()).unwrap();
        (
            SocketId::from_string(&id_str),
            &binary[BYTES_IN_WORD + len..],
        )
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PluginId(Uuid);

impl std::fmt::Display for PluginId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl PluginId {
    pub fn from_string(id: &str) -> Self {
        PluginId(Uuid::parse_str(id).unwrap())
    }

    pub fn to_binary(&self) -> Vec<u8> {
        let id_str = self.to_string();
        let len = id_str.len();
        let mut bin = vec![0; len + BYTES_IN_WORD];
        bin[0..BYTES_IN_WORD].copy_from_slice(&len.to_be_bytes());
        bin[BYTES_IN_WORD..].copy_from_slice(id_str.as_bytes());
        bin
    }

    pub fn from_binary(binary: &[u8]) -> (Self, &[u8]) {
        let len = usize::from_be_bytes(binary[0..BYTES_IN_WORD].try_into().unwrap());
        let id_str =
            String::from_utf8(binary[BYTES_IN_WORD..BYTES_IN_WORD + len].to_vec()).unwrap();
        (
            PluginId::from_string(&id_str),
            &binary[BYTES_IN_WORD + len..],
        )
    }
}
